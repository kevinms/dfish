                             pbwafer - Notes

Table of Contents

    1.  Frame Independent Movement
    2.  Regulating FPS
    3.  Playing Multiple Sounds at Once
    4.  Menu + Input System
    5.  Game Loop Psuedo-code
    6.  Packet Reliability

--------------------------------------------------------------------------------
1.                        Frame Independent Movement
--------------------------------------------------------------------------------
Here we define the dot related constants of width, height, and velocity.

Now that we're moving in relation to time instead of frame rate we have to
change how we handle velocity. Instead of basing velocity per frame we're going
to base it per second. In the original motion tutorial we had the dot travel 10
pixels every frame. Since the program ran at 20 frames per second that meant the
dot moved at a rate of 200 pixels per second.

So now the dot's velocity is 200 pixels per second.

Before we had to cap the frame rate to keep the dot from moving too fast. Here
we're going to make the dot move based on time instead of frame rate so it moves
the same no matter what the frame rate is.

--------------------------------------------------------------------------------
2.                              Regulating FPS
--------------------------------------------------------------------------------
When we started the frame, we started a timer to keep track of how much time it
took to output this frame. In order for this program not to run too fast, each
frame must take a certain amount of time. Since 20 frames are being shown per
second, each frame must take no less than 1/20th of a second. If the frame rate
is at 60 FPS, each frame must take no less than 1/60th of a second. Since this
demo is running at 20 FPS, that means we should spend 50 milliseconds (1000
milliseconds / 20 frames) per frame.

To regulate the frame rate, first we check if the frame timer is less than the
time allowed per frame. If it's more, it means we're either on time or behind
schedule so we don't have time to wait. If it is less, then we use SDL_Delay()
to sleep the rest of the frame time.

So if the frame timer in this program is at 20 milliseconds we sleep for 30
milliseconds. If the frame timer is at 40 milliseconds, we sleep for 10
milliseconds, etc, etc. 

--------------------------------------------------------------------------------
3.                     Playing Multiple Sounds at Once
--------------------------------------------------------------------------------
SDL_mixer is an extension library that makes using sound braindead easy.

g++ sdltest.c -o sdltest `sdl-config --cflags --libs` -lSDL_mixer

--------------------------------------------------------------------------------
4.                         Menu + Input System
--------------------------------------------------------------------------------
The menu system will really just be a visual represenation of all the hotkeys.
We don't want to bind commands to keys we want to give the game logic the
functions needed to do that.

Could just have a giant mapping of all keys and what they do.

menu_t *MENU_new(const char *name);
void MENU_add_entry(const char *name, keychain_t *kc, void (*callback)());
void MENU_add_menu(menu_t *);

typedef struct keychain_s
{
	// possibly a modifier
	// some type of series of keys
} keychain_t;

--------------------------------------------------------------------------------
5.                         Game Loop Psuedo-code
--------------------------------------------------------------------------------

done = 0
init vid sys
init render sys
init sound sys
init all default views
	main, chat, stats, ship editor, etc.

while(!done)
{
	if there is input
		check global keychains (should one of the modifiers: ctl, alt, mod4)
		check which view gets the input
			check view keychains
			check current menu keychains
	if there is data to recv
	if there is data to send

	update game internals
		physics, stats, etc.
	resolve collisions
	draw graphics
	if main view visible
		render main view
	if ship editor visible
		render ship editor
	
}

--------------------------------------------------------------------------------
6.                         Packet Reliability
--------------------------------------------------------------------------------
Unreliable
Unreliable packets are sent by straight UDP. They may arrive out of order, or 
not at all. This is best for data that is unimportant, or data that you send 
very frequently so even if some packets are missed newer packets will compensate.
Advantages - These packets don't need to be acknowledged by the network, saving
             the size of a UDP header in acknowledgment (about 50 bytes or so).
             The savings can really add up.
Disadvantages - No packet ordering, packets may never arrive, these packets are
                the first to get dropped if the send buffer is full.

Unreliable sequenced
Unreliable sequenced packets are the same as unreliable packets, except that
only the newest packet is ever accepted. Older packets are ignored.
Advantages - Same low overhead as unreliable packets, and you don't have to
             worry about older packets changing your data to old values.
Disadvantages - A LOT of packets will be dropped since they may never arrive
                because of UDP and may be dropped even when they do arrive.
                These packets are the first to get dropped if the send buffer is
                full. The last packet sent may never arrive, which can be a
                problem if you stop sending packets at some particular point.

Note that the transmission of one of the three reliable packets types is
required for the detection of lost connections. If you never send reliable
packets you need to implement lost connection detection manually.

Reliable
Reliable packets are UDP packets monitored by a reliablilty layer to ensure they
arrive at the destination.
Advantages - You know the packet will get there. Eventually...
Disadvantages - Retransmissions and acknowledgments can add significant
                bandwidth requirements. Packets may arrive very late if the
                network is busy. No packet ordering.

Reliable ordered
Reliable ordered packets are UDP packets monitored by a reliability layer to
ensure they arrive at the destination and are ordered at the destination.
Advantages - The packet will get there and in the order it was sent. These are
             by far the easiest to program for because you don't have to worry
             about strange behavior due to out of order or lost packets.
Disadvantages - Retransmissions and acknowledgments can add significant
                bandwidth requirements. Packets may arrive very late if the
                network is busy. One late packet can delay many packets that
                arrived sooner, resulting in significant lag spikes. However,
                this disadvantage can be mitigated by the clever use of ordering
                streams.

Reliable sequenced
Reliable sequenced packets are UDP packets monitored by a reliability layer to
ensure they arrive at the destination and are sequenced at the destination.
Advantages - You get the reliability of UDP packets, the ordering of ordered
             packets, yet don't have to wait for old packets. More packets will
             arrive with this method than with the unreliable sequenced method,
             and they will be distributed more evenly. The most important
             advantage however is that the latest packet sent will arrive, where
             with unreliable sequenced the latest packet sent may not arrive.
Disadvantages - Wasteful of bandwidth because it uses the overhead of reliable
                UDP packets to ensure late packets arrive that just get ignored
                anyway.
