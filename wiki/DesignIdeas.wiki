= Scope =

----
= Map Generation =
Maps will be created using procedural generation. Using a set of random seeds + a PRNG + a procedural function it should be possible to generate an entire map. An overly simple example would be:
  # Server receives requested map size from clients
  # Server generates a set of seed numbers
  # Server generates N random planetoid locations
  # Server creates a blueprint for each planetoid
  # Server generates properties and textures for each planetoid
  # Server generates random space debri blueprints around planetoids
  # Server populates its spacial indexing data structure with blueprints
  # Server sends all blueprints and map data to clients
  # Clients populate their spatial indexing data structure
Planetoids will be represented as blueprints and will be given a location somewhere in space. Using some noise generating functions like perlin noise it should be possible to create interesting textures for the planetoids.

References:
  * [http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_rand.aspx Random Number Generators]
  * [http://notch.tumblr.com/post/3746989361/terrain-generation-part-1 Procedural Generation]
  * [http://www.cs.clemson.edu/~kevin4/perlin.html Perlin Noise]

= Blueprints =
All information in the game is stored in blueprints. This includes entire ships, guns, floor tiles, wires, spacemen, etc. I will go into a bit more depth on how I think BPs (blueprints) should be stored and accessed a bit later. Whether or not maps will be a blueprint is undecided. Blueprints make up an entire hierarchy of objects. At the most basic level you have primitives.
{{{
typedef struct prim_s {
	int ch;
	char r,g,b;
	char fr,fg,fb;
} prim_t;
}}}
Primitives are a single character which can represent one type of tile. There could be hundreds/thousands of primitives. One might be a floor tile; another a wall tile; another a piece of glass; another a gold wire. Next up in the hierarchy is an entity.
{{{
typedef struct entity_s
{
	unsigned short id;
	unsigned int mass;
	unsigned int health;
	prim_t *p;

	// 2D Doubly-Linked List
	struct entity_s *n;
	struct entity_s *s;
	struct entity_s *e;
	struct entity_s *w;

	// Hashmap pieces
	int offset_x; // These could hashed and stored in a table
	int offset_y; // It would enable a much faster search

	// Linked List, will speed up looping through
	struct entity_s *next;
} entity_t;
}}}

Each entity is just an instance of a primitive. There could be a hundred instances of the wall primitive so each entity would just have a reference to the same wall tile. Now there are some variables that each instance needs to keep track of separately like id, mass, health, etc. which are also contained within the entity. Finally, each entity is a piece of a larger data structure. Actually, multiple data structures. Each one has its own benefits.
{{{
2D Doubly-Linked List:
 faster collision detection
 faster path finding

Hashmap:
 faster lookup

Linked List:
 faster iterating
}}}
Whether all these data structures will actually be used in the end is yet to be determined. Some data structures may use the principle of shifting computation in time to improve performance.

Entity positions will be stored relative to a base piece, e.g. (+20x -20y). The base piece can be either the visual center or center of mass which can be calculated.

An unsigned short or two bytes for entity IDs gives us 2^16 or 65536 ids. That means players can build blueprints with 2^16 tiles in them!

The final level is the blueprint itself:
{{{
typedef struct bp_s {
	entity_t *head;

	entity_t *center[3];

	entity_t *hull; // Just a pointer to a hull piece, this will hopefully speed
	                // up collision detection

	unsigned int mass;

	int x;
	int y;
} bp_t;
}}}

Information about an object as a whole is stored here. Such as mass, speed, position, etc. The entity pointers are again for quicker access and computation. The head pointer is for the first item in the linked list. The center entity will point to the 'center' of the blueprint object (which will be calculated on the fly). The hull entity will point to any hull tile (outside edge piece). This should quicken collision detection.

The next step is remembering dfish is an online multiplayer game. Each player will need to get some info on each ship out in space as other players build them. Also, since ships are completely  destructible they will need some way to tell which parts have been damaged/destroyed. It will be possible for blueprints to be split as well.

First, a limited blueprint will be sent to each player when it is built in the fabricator. This blueprint will not contain ALL the information about the blueprint only what is needed by the other clients.

Second, deltas will be sent over the network to each player to update each other of events that are happening to their blueprints. The name implies correctly that only the changes in the blueprint are sent. Much brain-thunderstorming needs to be done in this area before anything becomes close final in the code.
{{{
typedef struct delta_s
{
	//hmmm
} delta_t;
}}}

Nested Blueprints?

Should maps be BPs?

More Info:

  * Blueprints that are intended to move, such as ships, must have all pieces connecting. The fabricator can give errors telling the requirements.
  * We can calculate the final velocity of the object and have it display in a stats window

  * Blueprints will list entities pieces along with id (e.g. door = 42, id = 1), ID will help link entities
OR
  * Blueprints will list entities pieces (e.g. door = 42), entity position will help link entities
  * If an entity is moved or destroyed you search to destroy the link

{{{
// Archie says :)
We might need to check if a wall has been damanged enough for space to come in 
}}}

== Layers of Ship Design ==

----

= Interface =

----

= Management of Units =
<wiki:comment> Potentially inapplicable </wiki:comment>
----

= Cosmetic Effects =
 * When a ship is destroyed, little space men should be visible floating out into space.
----

= Scaling over the course of the game =

----

= Entities =
== Ship Parts ==
== Raw Materials ==
== Larger-Scale Tiles ==