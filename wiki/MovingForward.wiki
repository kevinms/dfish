#summary What needs to be done next to keep the project moving!

Here you will find a listing of items that need to be completed soon. We will try to include as much information as possible about each task.

===Tasks===

|| *Stage* || *Topic* || *Description* || 
|| _done_|| Blueprint Structs || Finalize as much as possible what members each struct will need and create new ones as needed. ||
|| _in progress_ || Blueprint Deltas || Extremely important for good network play. Lots of brain-thunderstorming needs to happen for this. Any ideas you have should be brought to the table. The sooner we can get this going the sooner we will have a playable game ||
|| _in progress_ || Networking Code || There are a few known bugs lurking in the networking code. Also there is no flow control algorithm implemented as of yet. Packet sending needs to be buffered. Network simulator needs to be finished. ||
|| _planning_ || Fabricator || This is in it's infancy and is needed to build blueprints in game. I think the blueprint design should be a little more finale before moving on here. ||
|| _none_ || Blueprint Saving || Functions to save blueprints to disk for later use/reference. This function will change as the blueprint structure itself evolves. Careful planning is needed. ||

===TODO====
Results of a large brainstorming session:

{{{
------------------------------------------------------------------------
full blueprint packing
------------------------------------------------------------------------

For each entity pack: id, primitive type, offset_x, offset_y, health, layer

All the blueprint data structures (linkedlist hasmap 2d-linkedlist) can
be computed easily on each host:

So lets say the incoming packets has a series of the above variables.
As it unpacks each one it creates a new entity and adds it to a linked
list. It then loops through the completed linked list and hashes all the
entities using the offset_x and offset_y. Then it loops through the list
again but this time running hashmap lookups to determine if pieces are
next to it. If there is a piece next to it then set the pointer. If not 
set null. That should completely rebuild the blueprint

------------------------------------------------------------------------
implement a hash table for blueprints
------------------------------------------------------------------------

Check eternally confuzzled!

Our hash table will use separate chaining for handling collisions. The
major reasons are:
  + it can handle deletion of keys easily - destroying entities will be
    a common operation this is needed
  + it can handle duplicate keys easily - the x,y offsets will be used
    as the key in the hash table, entities may have the same offsets
    since there are multiple layers of entities

When the game is in a playable state comparison of hash functions will
have to be done on the blueprint data sets to minimize collisions.

Again, eternally confuzzled is a good resource to find many common
hashing algorithms that are very quick and can achieve avalanche!

------------------------------------------------------------------------
blueprint delta packing
------------------------------------------------------------------------

Three delta types:
  delete
  add
  update (many types)

Data to pack:

Delete:
Only the id is needed. Each client can do a lookup to find the correct
entitity to delete.

Add:
It would pack: [id, primitive_type, offset_x, offset_y, health, layer]
for each entity that was added. Hash lookups can be used to set all the
pointers for the entity.


Update:
It would pack: [id, update_type, delta1, delta2, ...] The update_type
will be a bitfield where bits are set to show which updates have
occured. You would check the bitfield to see how many updates there are
for that entitity and know how many to unpack. The series of delta*
would just reflect the change in a variable like -20 for health.

------------------------------------------------------------------------
buffering blueprint packet data in the fabricator
------------------------------------------------------------------------

Lets assume a new bluprint is 100*100 tiles so:
10,000 entities * 14 bytes/entity = 140,000 bytes = 140 KB

It would take about this long to send the blueprint all at once:
150,000 bytes / (600 bytes/packet * 30 packets/sec) = 8.3 seconds

We dont want to send 140 KB in one go unless we have to. Instead we
spread out the data transfer over time by constantly sending bp updates
while they are creating it in the fabricator. Each time they add/del
entities we begin to fill a fixedbuf with the delta packet data. Once
the buffer gets to a certain size we send it off to the networking
layer to be transmitted to the server. OR If they finalize the bp
before the buffer if full go ahead and send the data.

------------------------------------------------------------------------
buffering packets in the networking layer
------------------------------------------------------------------------
Need to have a fixedbuf_t that stores up to X bytes of data before
sending. It will be filled with packets fromt the packet_queue.

------------------------------------------------------------------------
determine average packet size/rate for realtime games
------------------------------------------------------------------------

Estimated average packet statistics:
30 packets/sec at ~512 B/packet = ~15 kB/s

Client upload speeds are the limiting factor ranging from 10 kB/s
to 50 kB/s. We should not flood the clients with data from the server
even though download speeds are much higher. The ack bitfield can only
support a certain number of acks per second.

It is suggested by Glenn Feidler to have several states you can drop
into depending on your current network conditions. We might use 3
states being 10, 30, 60 packets/sec. On LANs this rate can be increased
even more.

Resources:
http://gafferongames.com/networking-for-game-programmers/reliability-and-flow-control/
Google search, wireshark capturing, etc.

}}}